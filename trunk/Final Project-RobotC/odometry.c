//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

///Whatever

/*
#pragma config(Sensor, S1,     OBSTACLE_SENSOR,     sensorSONAR)
#pragma config(Sensor, S2,     BALL_SENSOR,         sensorSONAR)
#pragma config(Sensor, S3,     lightSensor,         sensorLightActive)
#pragma config(Sensor, S4,     ballSensor,          sensorLightActive)*/
#ifndef _ODOMETRY_
#define _ODOMETRY_

#include "math.c"

task UpdateValues();


//Global variables used


//Linear distance the wheel travels by rotating one degree
//in milimeters
float mmPERdeg = 0.455;

//Distance between wheels in milimeters
//USE ***153*** for the scooper
//USE ***143*** for the loader


#ifdef __LOADER__
int distanceBetweenWheels = 143;
#endif

#ifdef __SCOOPER__
int distanceBetweenWheels = 153;
#endif

//Theta - angle the robot turned
//x,y - current position of robot
//dx, dy - distance robot moved since last sample
float x = 0, y = 0;
float theta = 0;

float tempX =0, tempY = 0;

float deg2rad(float deg){
	return PI*deg / 180;
}

float rad2deg(float rad){
	return 360*rad / 2*PI;
}

//Get the distance covered by a wheel by rotating a number of degrees
//in tenths of a millimeter
float degToMM(long degrees){
     return degrees*mmPERdeg;
}

//Find out the angle of the arc described by the robot, theta
//Theta is in of radians
float getmTheta(float wLeftDist, float wRightDist){
    float tmp1 = wRightDist-wLeftDist;
    return (tmp1/distanceBetweenWheels);
}

// Get the length of the arc described by the robot
float getArc(float wLeftDist, float wRightDist){
    return (wRightDist+wLeftDist)/2;
}

//Correct the distance from an arc to a chord
float correction2Cord(float theta){
     float a = theta/2;
     if (theta==0)
        return 1;
     else return (sin(a)/a);
}




//This task updates the current position based on wheel rotation
//It samples as often as possible. The more samples, the better the precision.
//Theta = current heading
task UpdateValues() {

	//variables used for internal stuff
int wLeftDeg = 0;
int wRightDeg = 0;

float wRightDist = 0;
float wLeftDist = 0;
float arc = 0;
float dx = 0 , dy = 0;

	float newTheta;

	long newWLeftDeg;
	long newWRightDeg;



	while(true){
		//Get the values from the global variable
		newWLeftDeg = nMotorEncoder[motorA];
		newWRightDeg = nMotorEncoder[motorB];


		//Compute theta based on the two wheels
		newTheta = getmTheta(degToMM(wLeftDeg) , degToMM(wRightDeg));

		//Adjust theta so that it's always between 0 and 6.283 (2*PI)
		newTheta = NormalizeHeading(newTheta);

		//Fi is the angle of the vector joining the old and new position
		//fi = (newTheta + theta)/2;

		//Update theta
		theta = newTheta;

		//Only need to do something if the robot moved
		if(newWLeftDeg!=wLeftDeg || newWRightDeg!=wRightDeg){
			//Compute the distance each wheel moved
			wLeftDist = degToMM(newWLeftDeg - wLeftDeg);
			wRightDist = degToMM(newWRightDeg - wRightDeg);

			//Update the values for each wheel
			wLeftDeg = newWLeftDeg;
			wRightDeg = newWRightDeg;

			//Get the length of the arc we moved
			arc = getArc(wLeftDist, wRightDist);

			//Correct such that we get the chord of the arc, for better precision.
//			long correction = correction2Cord(theta);
//			correctedVector = arc * correction;

			//Compute dx and dy

			dx = (arc * cos(theta));
			dy = (arc * sin(theta));

			//Update our position
			tempX = x;
			tempY = y;

			y = y + dy;
			x = x + dx;
		}
	}
}



//Sample the reading of the US sensor a couple of times to get
//an accurate reading.
int getDistance(int SensorPort, int samples){
	int i = 0, value = 0;
	long sum = 0;
	int err = 0;
	int smp = 0;
	while( i < samples){
		value = SensorValue[SensorPort];
		if (value != 255){
			sum += value;
			smp++;
		}
		else
		{
			err ++;
		}
		i++;
	}
	if (err < samples /2 )
		return sum / smp;
	else return 255;
}
//Initializes the sensors on the correct ports
//Acquires the shoulMove mutex such that when it is first started
//the Drive task is put to sleep (as it tries to acquire the same mutex)
//Starts the tasks
//Initializes variables


#endif
