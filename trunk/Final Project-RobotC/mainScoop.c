#pragma config(Sensor, S1,     OBSTACLE_SENSOR,     sensorSONAR)
#pragma config(Sensor, S2,     BALL_SENSOR,         sensorSONAR)
#pragma config(Sensor, S3,     lightSensor,         sensorLightActive)
#pragma config(Sensor, S4,     ballSensor,          sensorLightActive)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/* This version has only been tested in a stand-alone environment.....

Final testing will be done after integrating with the loading/ unloading code.....


QUESTION : WOULD IT BE BETTER IF I MAKE THE RAISE AND LOWER SUBROUTINES INTO TASKS

THAT WAY I COULD CONTROL THEM USING hogCpu() and releaseCpu() ( EQUIVALENT TO MUTEXES IN NXC)
*/
#define __SCOOPER__

#include "navigation.c"
#include "bluetooth.c"
#include "initialHeading.c"

void RotateMotorEx(short motorX, int power, int degrees){
  // 	bFloatDuringInactiveMotorPWM = false;
  /*	nMotorEncoderTarget[motorX]=degrees;
  motor[motorX]=speed;


  while(nMotorRunState[motorX]!= runStateIdle);
  */

  long initial;
  initial = nMotorEncoder[motorX];
  motor[motorX] = power;
  if (power >= 0)
    while (nMotorEncoder[motorX] < initial + degrees);//Too many degrees!
  else
    while (nMotorEncoder[motorX] > initial - degrees);

  motor[motorX]=0;
}



// lower and raise subroutines are based on the fact tht the scooper is fully retracted

void lower()
{

  // recieve signal from the ball detection code

  wait1Msec(1000);
  RotateMotorEx(motorC,30,60);
  //return true;
}

void dropoff();
void raise()
{

  // receive signal from the loader
  wait1Msec(500);
  RotateMotorEx(motorC,-50,60);
  //return true;
}



void initial()
{
  wait1Msec(1000);
  RotateMotorEx(motorC,40,40)
}
void dropoff(){
  wait1Msec(500);
  RotateMotorEx(motorC,-60,60);
}



task main{

	StartTask(UpdateValues);
	wait10Msec(100);
	RotateHelper(2*PI, 35);
	GoToHeading(-PI/2, 35);
	StopTask(UpdateValues);

	x = 3000;
	y = 0;
	theta = 0;

	nMotorEncoder[motorA] = 0;
	nMotorEncoder[motorB] = 0;

	StartTask(UpdateValues);
	wait10Msec(100);


int xCup=1900, yCup=1900, ThetaCup=0;
int xCup2 = 2100, yCup2 = 1900;



int iX, iY, iTheta;


			navigate(xCup,yCup, true, true, 1);
			navigate (xCup2, yCup2, true, true, 1);
			GoToHeading(PI, 30);

//initialHeading();
//navigate(xCup,yCup, true, true, 1);


while(true){
	//while ( !bQueuedMsgAvailable()); //Wait here indefinetly

	btreceive();
  wait1Msec(100);
	switch (msgParams[0]){
		case GOTOCUP:
		{
/*			navigate(xCup,yCup, true, true, 1);
			navigate (xCup2, yCup2, true, true, 1);
			GoToHeading(ThetaCup, 30);
			btsend(CONFIRMATION,0,0);*/
			break;
		}
		case LOWER_SCOOP:
		{
			lower();
			btsend(CONFIRMATION,0,0);
			break;
		}
		case LIFT_SCOOP: //this is the one where the ball stays in the scoop ok
		{
			raise();
			btsend(CONFIRMATION,0,0);
			break;
		}
		case UNLOAD_BALLS:
		{
      RotateHelper(deg2rad(90), 30);
			dropoff(); //Raise scoop at maximum
			RotateHelper(deg2rad(-90), 30);
			lower();
			btsend(CONFIRMATION,0,0);
			break;
		}
		case GO_TO_WAITING_STATE:
		{
			navigate(iX, iY, true, true, 1);
			btsend(CONFIRMATION,0,0);
//			initialHeading(); //Re-calculate heading, for v good precision
			break;
		}
		wait10Msec(4);
	}
	ClearMessage();
		ClearMessage();
			ClearMessage();
				ClearMessage();
					ClearMessage();
}

}
