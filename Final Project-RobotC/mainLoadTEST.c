#pragma config(Sensor, S1,     OBSTACLE_SENSOR,     sensorSONAR)
#pragma config(Sensor, S2,     BALL_SENSOR,         sensorSONAR)
#pragma config(Sensor, S3,     lightSensor,         sensorLightActive)
#pragma config(Sensor, S4,     ballSensor,          sensorLightActive)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define __LOADER__


#include "navigation.c"
#include "initialHeading.c"
#include "bluetooth.c"

#define BALLMIN 28
#define BALLMAX 20


//global variables
int ballnumber=1; //ballno
int startLoader=2;//when 1 is sent from the master, CaptureBall is called, at the end, startLoader is set back to C


void RotateMotorEx(short motorX, int speed, unsigned int degrees){
	nMotorEncoderTarget[motorX]=degrees;
	motor[motorX]=speed;

	while(nMotorRunState[motorX]!= runStateIdle);
	//	bFloatDuringInactiveMotorPWM = false;


}



//////////////
//Puts the ball inside the mill thingy
////////////////////

void initprepBall(int ballno) {

	if(ballno != 3) {

		RotateMotorEx(motorC, 30, 90);
		wait1Msec(1500);
	}

}


//Checks that the ball has indeed been loaded
bool prepBall(){

	RotateMotorEx(motorC, -15, 50);

	wait1Msec(2000);

	if(SensorValue[ballSensor] >= BALLMIN || SensorValue[ballSensor] <= BALLMAX){
		RotateMotorEx(motorC, 15, 50);
		return true;
	}

	else
	{
		RotateMotorEx(motorC, 15, 50);
		return false;
	}
}





/////////////////
//LOAD FUNCTION
//////////////

void Loader(){

	//  i is a counter that is incremented each time the loader function is called, by the ball detection code */

	if (ballnumber<4) {
		ballnumber++;

		switch(ballnumber)
		{

		case 1: // load the first ball
			{

				//Wait(1000);  // loader waits 1 second

				RotateMotorEx(motorC,30,360);
				wait1Msec(200);
				return;

			}

		case 2:
			{
				//wait1Msec(1000);  // loader wait1Msecs 1 second

				RotateMotorEx(motorC,40,360);
				wait1Msec(150);
				return;

			}

		case 3:
			{

				//wait1Msec(1000);  // loader wait1Msecs 1 second

				RotateMotorEx(motorC,30,110);
				wait1Msec(100);
				return;
			}

		}
}}



//////////////////////////////////////
//unload function.
/////////////////////////////////

void unload(int ballno){

	initprepBall(ballno);

	while(!prepBall()){
		prepBall();    //prepball to put ball in correct location
	}

	wait1Msec(2000);

	RotateMotorEx(motorC, -30, 90);   //eject

	ballnumber--;

	wait1Msec(500);
	//lowerEff();
	return;
}


void LoadBall(){

	float startX = x, startY = y;
	StartForward(24);
	while ( SensorValue[ballSensor] < BALLMIN &&
		euclidDistance(startX, startY, x, y) < 500
	);

	if ( SensorValue[ballSensor] >= BALLMIN)
		Loader();
	StopMotors();
}

void captureBall(){


	while(true){
		if(SensorValue[ballSensor] >= BALLMIN || SensorValue[ballSensor] <= BALLMAX){
			Loader();

			//Change variable to notify capture
			break;
		}
	}
	startLoader=2;

}

float xTarget = 0;
float yTarget = 0;

int targetIndex = 0;

#define waypointCount 5

int xPos[waypointCount] = {2000, 2000,  600,  1200, 900};
int yPos[waypointCount] = {600, 900,    900,   600, 600};

void SelectNextWaypoint(){
	targetIndex %= waypointCount;

	xTarget = xPos[targetIndex];
	yTarget = yPos[targetIndex];

	targetIndex++;
}

task main(){




	StartTask(UpdateValues);
	wait10Msec(100);
	Rotate(PI, 30);
	Rotate(PI,30);
	GoToHeading(-PI/2, 35);
	StopTask(UpdateValues);


	x = 0;
	y = 0;
	theta = 0;

	nMotorEncoder[motorA] = 0;
	nMotorEncoder[motorB] = 0;

	StartTask(UpdateValues);
	wait10Msec(100);
	int xCup=1500, yCup=1900, ThetaCup=0;



	//int arrived = NOT_ARRIVED;

	//FindBallHeading();

	SelectNextWaypoint();
	while (true){
		while (ballnumber < 3 ){ //|| (TimeSpent < 5)
				int result;
			result = navigate(xTarget,yTarget, false, true, 1);

			if (result == ARRIVED_AT_TARGET){
				SelectNextWaypoint();
			}
			else //(result == FOUND_BALL)
			{
				//findBallHeading();
				//FindBallDistance();

				//Check if there is an angled wall

				float startX = 0, startY = 0;

				int faults = 0;

				StartForward(10);
				while (euclidDistance(startX,startY,x,y,) < 40){
					if (SensorValue[BALL_SENSOR] == 255)
						faults++;

					if (faults > 30){
						StopMotors();
						GoBackwards(50, 25);
						RotateHelper(deg2rad(-70), 25);

						float startX2 = x, startY2 = y;
						StartForward(24);
						while ( SensorValue[ballSensor] < BALLMIN &&
							euclidDistance(startX2, startY2, x, y) < 220
						);
						StopMotors();


						break;
					}
				}

				StopMotors();

				if (faults < 30){
					RotateHelper(deg2rad(-9), 25);
					wait10Msec(100);
					LoadBall();
				}
				//wait10Msec(1000);
			}
		}

		navigate(xCup, yCup, true, true, 1);
		GoToHeading(0, 25);
		GoForward(400, 25);

		//navigate(xCup2, yCup2, true, true, 1);

		//At this point we should have 3 balls or be late

		while(ballnumber !=0){

			/*	btsend(GOTOCUP,0,0);

			while(!CONFIRMATION) //Wait until it gets here
			wait1Msec(1);*/

			btsend(LOWER_SCOOP,0 , 0);

			while(msgParams [0] != CONFIRMATION) //Wait until it gets here
				btreceive();


			//CHANGE HERE THE NUMBER OF BALLS TO BE DUMPED!!!

			wait1Msec(2000);
			unload(ballnumber); //1 or three balls??

			btsend(LIFT_SCOOP,0,0);

			while(msgParams[0] != CONFIRMATION) //Wait until it gets here
				btreceive();

			btsend(UNLOAD_BALLS,0,0);

			while(msgParams[0] != CONFIRMATION) //Wait until it gets here
				btreceive();

		}


	}
}
