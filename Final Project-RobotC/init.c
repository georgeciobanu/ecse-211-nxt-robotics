#pragma config(Sensor, S1,     lightSensor,         sensorLightActive)
#pragma config(Sensor, S2,     compass,             sensorI2CHiTechnicCompass)
#pragma config(Sensor, S3,     sonarSensor,         sensorSONAR)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "control.c"
#define COMPASS_HEADING 40

bool detectBlackLine() {
  return SensorValue(lightSensor);
}

void startMotor(int power) {
	nSyncedMotors = synchAB;
	nSyncedTurnRatio = 100; //not 100% because of symmetry issues at low speed
	motor[motorA]=power;

	while(!detectBlackLine());
	motor[motorA]=0;
	bFloatDuringInactiveMotorPWM = false;
}

void SetInitialPosition(int power) {
	GoToHeading(0, power);
	startMotor(power);
	GoToHeading(PI/2, power);
	startMotor(power);
}

float getInitialHeading() {
	return 0;
}
int i=0;
task I() {
	while(true) {
		i++;
	}
}
task main() {
	int power=20;
	theta = SensorValue(compass);


	nSyncedMotors = synchAB;
  nSyncedTurnRatio = -100; //not 100% because of symmetry issues at low speed
//  	  	repeat(3)
	while(theta!=COMPASS_HEADING) {
	  theta = SensorValue(compass);
	 	if(theta>COMPASS_HEADING) {
		  if(theta-COMPASS_HEADING>180) {
	  	  motor[motorA]=power;
	  	} else {
  	  	motor[motorA]=-power;
		  }
	 	}
	  else {
		  if(COMPASS_HEADING-theta>180) {
		    motor[motorA]=-power;
  		} else {
	 		  motor[motorA]=power;
	  	}
	  }
	}
	motor[motorA]=0;

	nSyncedMotors = synchNone;
	bFloatDuringInactiveMotorPWM = false;

  theta=0;
  StartTask(UpdateValues);
#ifdef LOADER
  RotateHelper(-PI/2, power);
  int dist2 = GetDistance(10);
  RotateHelper(PI, power);
  int dist = GetDistance(10);
#else
wait1Msec(1000);
  int dist = GetDistance(10);
  RotateHelper(-PI/2, power);
  wait1Msec(1000);
  int dist2 = GetDistance(10);
#endif
  StopTask(UpdateValues);
  x = dist;
  y = dist2;
  while(true);

}
