#pragma config(Sensor, S4,     US,                  sensorSONAR)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "control.c"

float minDist;
float d1;
float d2;
float h;
float iniX;
float iniY;
float iniH =0;
float secondWallAngle;
float firstWallAngle;
int power = 40;

task getMinDist(){

	minDist = SensorValue[S4];
	while(true){
		if (SensorValue[S4]<minDist){
			minDist = SensorValue[S4];
			h = theta
		}
	}
}

task initialDirection(){
	if (SensorValue[S4]<80)//if facing walls
	  iniH = PI;
	else
	  iniH = 0;
	StartTask(getMinDist);
	RotateHelper(-2*PI, 40);
	StopTask(getMinDist);

	d1 = minDist;
	firstWallAngle = h;

	wait10Msec(100);
	GoToHeading(firstWallAngle, power); // Face closest wall

/*
	Rotate(-PI/2, power); //rotate 90 degrees clockwise


	if (SensorValue[S4]<50){ //if you see a wall

		Rotate(PI/4-0.1, power); //rotate 45 degrees to left

		StartTask(getMinDist);
		Rotate(-PI/2, power);  //find minimum distance by rotating 90 degrees right
		StopTask(getMinDist);

		d2 = minDist;
		secondWallAngle = h;
		iniX = d2*100;
		iniY = d1*100;


	}
	else {					//if not facing a wall

		Rotate(-3*PI/4+0.1, power);  //rotate 135 degrees right

		StartTask(getMinDist);
		Rotate(-PI/3, power);  //find minimum distance by rotating 90 degrees right
		StopTask(getMinDist);

		d2 = minDist;
		float secondWallAngle = h;
		iniX = d1*100;
		iniY = d2*100;

	}

	float avg = (firstWallAngle + secondWallAngle)/2;
	iniH = iniH + avg-PI/4 + PI;
	GoToHeading(iniH, power);

	wait10Msec(100);
	StopTask(UpdateValues);
	theta = 0;
	x = iniX;
	y = iniY;
	nMotorEncoder[motorA] = 0;
	nMotorEncoder[motorB] = 0;
	StartTask(UpdateValues);
*/
}

task main(){
	StartTask(UpdateValues);
	StartTask(initialDirection);
	//GoToXY(200, 300, 40);

	while(true)
		wait10Msec(1000);
}
