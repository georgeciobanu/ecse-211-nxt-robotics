#pragma config(Sensor, S4,     IN_4,                sensorSONAR)
#pragma config(Motor,  motorA,          OUT_A,         tmotorNormal, PIDControl, )
#pragma config(Motor,  motorB,          OUT_C,         tmotorNormal, PIDControl, )
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "control.c"

#define CHAR_WIDTH 6
#define DegToDistance 227 // Degrees per meter
#define DistanceToDeg 227//1 mm per degree *1000
#define DegToOrient 255 // (Rw/Rc)*1000 should be 423
#define OrientToDeg 236 // (Rc/Rw)*100 should be 235
#define Ball_x 100
#define Ball_y 80
#define FWDSPD 40
#define Deg_Band 3
#define BASESPEED  30
#define DELTASPEED 5
#define SPEEDPLUS  BASESPEED+DELTASPEED
#define SPEEDMINUS BASESPEED-DELTASPEED
#define Ultrasonic 25
#define Ultrasonic_1 20

void case_1();
void case_2();
void case_3();
void case_4();

float degrees=0;
long xpos=0;
long ypos=0;
long Angle=0;
long Current_x,Current_y,Current_Deg;
int Deg_flag=101,Deg_correction;

int USreading(){
	int DistanceUS=0;
    int count_1 =0;
    int count_2=0;
    int Temp_x=0;
    int x;
	repeat(7)
    {
		x = SensorValue(IN_4);
		if(x == 255)
			count_1++;
		else
		{
			count_2++;
            Temp_x+=x;
		}
	}
	if(count_1>count_2)
		DistanceUS = 255;
	else if(count_1<count_2)
		DistanceUS = Temp_x/count_2;
	return DistanceUS;
}

task odometer(){

	long newA,oldA=0,currentA,newC,oldC=0,currentC;
    long distance,Delta_x,Delta_y;
    long Delta_Angle=0;

	while (true) {
		newA = nMotorEncoder[OUT_A];
        currentA = newA - oldA;
        oldA = newA;
        newC = nMotorEncoder[OUT_C];
        currentC = newC - oldC;
        oldC = newC;
        distance = (currentA + currentC)*DegToDistance;
        Delta_Angle=(currentC-currentA)*DegToOrient;
		long Temp = Angle + Delta_Angle;
		if (Temp >= 360000) {
			Angle = Temp -360000;
			}
		else if (Temp < 0) {
			Angle = Temp + 360000;
			}
		else {
			Angle = Temp;
			}
		degrees=Angle/1000;
		//Delta_x = distance*Cos(degrees);
		//Delta_y= distance*Sin(degrees);
		Delta_x = distance*Cos(degrees*2*PI/360)*100;
		Delta_y= distance*Sin(degrees*2*PI/360)*100;
		xpos += Delta_x;
		ypos += Delta_y;
/*
		ClearScreen();
        TextOut(0,LCD_LINE1,"Degrees : ");
        TextOut(0,LCD_LINE2,"x pos ");
        TextOut(0,LCD_LINE3,"y pos ");
        TextOut(0,LCD_LINE4,"Deg_flag");
//TextOut(0,LCD_LINE4,"US_Reading : ");
        NumOut(10*CHAR_WIDTH,LCD_LINE1,degrees);
        NumOut(10*CHAR_WIDTH,LCD_LINE2,xpos/1000000);
        NumOut(10*CHAR_WIDTH,LCD_LINE3,ypos/1000000);
        NumOut(10*CHAR_WIDTH,LCD_LINE4,Deg_flag );
//NumOut(20*CHAR_WIDTH,LCD_LINE4,SensorUS(IN_4));
        */
        wait1Msec(100);
        Current_x=xpos/1000000;
        Current_y=ypos/1000000;
        Current_Deg=degrees;
		}
	}

void RotationR_90(){
	RotateHelper(PI/2, 40);
	/*
	while(true){
		RotateMotor(OUT_C, 40, 180);
        RotateMotor(OUT_A, -40, 180);
        wait1Msec(640);
        OffEx(OUT_AC, RESET_NONE);
        wait1Msec(1000);
		break;
		}
		*/
	Deg_flag++;
	}

void RotationL_90(){
	RotateHelper(-PI/2, 40);
	/*
	while(true){
		RotateMotor(OUT_A, 40, 180);
		RotateMotor(OUT_C, -40, 180);
		wait1Msec(640);
		OffEx(OUT_AC, RESET_NONE);
		wait1Msec(1000);
		break;
		}
		*/
	Deg_flag--;

	}

void case_1()
	{
	if((Deg_flag==3)||(Deg_flag%4==3))
		RotationL_90();
	else if(Deg_flag%4==0)
		RotationL_90();
	while(true){
		if((Current_x<Ball_x)&&(Current_y<Ball_y)){
			StartForward(FWDSPD);
//			StartForward(FWDSPD);
			if((Current_x<Ball_x)&&(Current_y<Ball_y)){
				if((Deg_flag==1)||(Deg_flag%4==1)){
					if(USreading()<Ultrasonic){
						StopMotors();
//							StopMotors();
						wait1Msec(300);
						RotationR_90();
						if(USreading()<Ultrasonic){
							RotationL_90();
							StartForward(-FWDSPD);
//							StartForward(-FWDSPD);
							wait1Msec(1000);
							StopMotors();
//							StopMotors();
							RotationR_90();
							StartForward(FWDSPD);
//							StartForward(FWDSPD);
							}
						else
						  StartForward(FWDSPD);
//							StartForward(FWDSPD);
						}
					else
						  StartForward(FWDSPD);
//						StartForward(FWDSPD);
					}
				if((Deg_flag==2)||(Deg_flag%4==2))
					{
					if(USreading()<Ultrasonic){
							StopMotors();
//						StopMotors();
						wait1Msec(300);
						RotationL_90();
						if(USreading()<Ultrasonic){
							RotationR_90();
							StartForward(-FWDSPD);
//							StartForward(-FWDSPD);
							wait1Msec(1000);
							StopMotors();
							RotationL_90();
							StartForward(FWDSPD);
//							StartForward(FWDSPD);
							}
						else
						  StartForward(FWDSPD);
//							StartForward(FWDSPD);
						}
					else

						  StartForward(FWDSPD);
//						StartForward(FWDSPD);
					}
				}
			}
		else{
			StopMotors();
//			StopMotors();
			if((Deg_flag==1)||(Deg_flag%4==1))
				{
				wait1Msec(300);
				RotationR_90();
				StartForward(FWDSPD);
//				StartForward(FWDSPD);
// Tony made changes here

/*  This part is dealing with obstacles standing in the x,y axis while the Robot
travelling toward to the ball just found by the 1st Robot.
In the case that the Robot encounters an obstacle along x,y axis, it will always
turn right, travel for some distance, thus falls into another case*/
//Version_1
				if(USreading()<Ultrasonic){
					RotationL_90();
          StartForward(FWDSPD);
					wait1Msec(2000);
					StopMotors();
					/*wait1Msec(1000);
					case_4();
					break;*/
					}
//Version_2
/*if(USreading()<Ultrasonic){
					RotationL_90();
          StartForward(FWDSPD);
					wait1Msec(2000);
					StopMotors();
					wait1Msec(1000);
					break;
					}*/
				until(Current_y==Ball_y);
				StopMotors();
				break;
				}
			else if ((Deg_flag==2)||(Deg_flag%4==2)){
				wait1Msec(300);
				RotationL_90();
				StartForward(FWDSPD);
//        StartForward(FWDSPD);
				  if(USreading()<Ultrasonic){
					RotationR_90();
          StartForward(FWDSPD);
					wait1Msec(2000);
					StopMotors();
					wait1Msec(1000);
					/*case_2();
					break;*/
					}
				until(Current_x==Ball_x);
				StopMotors();
				break;
				}
			}
		}
	}

void case_2()
{
if((Deg_flag==3)||(Deg_flag%4==3))
RotationR_90();
else if((Deg_flag==2)||(Deg_flag%4==2))
RotationL_90();

wait1Msec(1000);

while(true){
if((Current_x<Ball_x)&&(Current_y>Ball_y)){

StartForward(FWDSPD);


if((Current_x<Ball_x)&&(Current_y>Ball_y)){

if((Deg_flag==1)||(Deg_flag%4==1))
{
if(USreading()<Ultrasonic){
StopMotors();
wait1Msec(300);
RotationL_90();
if(USreading()<Ultrasonic){
RotationR_90();
//Go_straightline();
StartForward(-FWDSPD);
wait1Msec(1000);
StopMotors();
RotationL_90();
StartForward(FWDSPD);
                  }
else
StartForward(FWDSPD);
                  }
else
StartForward(FWDSPD);
}
if((Deg_flag==4)||(Deg_flag%4==0))
{
if(USreading()<Ultrasonic){
StopMotors();
wait1Msec(300);
RotationR_90();
if(USreading()<Ultrasonic){
RotationL_90();
StartForward(-FWDSPD);
wait1Msec(1000);
StopMotors();
RotationR_90();
StartForward(FWDSPD);
                  }
else
StartForward(FWDSPD);
                  }
else
StartForward(FWDSPD);
}

                  }

                                             }
else
{
StopMotors();
if((Deg_flag==1)||(Deg_flag%4==1))
{
wait1Msec(300);
RotationL_90();
StartForward(FWDSPD);

if(USreading()<Ultrasonic){
					RotationR_90();
          StartForward(FWDSPD);
					wait1Msec(2000);
					StopMotors();
					wait1Msec(1000);
					case_3();
					break;
					}

until(Current_y==Ball_y);
StopMotors();
break;
}
else if ((Deg_flag%4==0)){
wait1Msec(300);
RotationR_90();
StartForward(FWDSPD);
if(USreading()<Ultrasonic){
					RotationL_90();
          StartForward(FWDSPD);
					wait1Msec(2000);
					StopMotors();
					wait1Msec(1000);
					case_1();
					break;
					}
until(Current_x==Ball_x);
StopMotors();
break;
}
}
}
}

void case_3()
{
if((Deg_flag==1)||(Deg_flag%4==1))
RotationL_90();
else if((Deg_flag==2)||(Deg_flag%4==2))
RotationR_90();
while(true){
if((Current_x>Ball_x)&&(Current_y>Ball_y)){

StartForward(FWDSPD);

if((Current_x>Ball_x)&&(Current_y>Ball_y)){

if((Deg_flag==3)||(Deg_flag%4==3))
{
if(USreading()<Ultrasonic){
StopMotors();
wait1Msec(300);
RotationR_90();
if(USreading()<Ultrasonic){
RotationL_90();
//Go_straightline();
StartForward(-FWDSPD);
wait1Msec(1000);
StopMotors();
RotationR_90();
StartForward(FWDSPD);
                  }
else
StartForward(FWDSPD);
                  }
else
StartForward(FWDSPD);
}
if((Deg_flag==4)||(Deg_flag%4==4))
{
if(USreading()<Ultrasonic){
StopMotors();
wait1Msec(300);
RotationL_90();
if(USreading()<Ultrasonic){
RotationR_90();
StartForward(-FWDSPD);
wait1Msec(1000);
StopMotors();
RotationL_90();
StartForward(FWDSPD);
                  }
else
StartForward(FWDSPD);
                  }
else
StartForward(FWDSPD);
}

                  }

                                             }
else
{
StopMotors();
if((Deg_flag==3)||(Deg_flag%4==3))
{
wait1Msec(300);
RotationR_90();
StartForward(FWDSPD);
if(USreading()<Ultrasonic){
					RotationL_90();
          StartForward(FWDSPD);
					wait1Msec(2000);
					StopMotors();
					wait1Msec(1000);
					case_2();
					break;
					}
until(Current_y==Ball_y);
StopMotors();
break;
}
else if ((Deg_flag==4)||(Deg_flag%4==0)){
wait1Msec(300);
RotationL_90();
StartForward(FWDSPD);
if(USreading()<Ultrasonic){
					RotationR_90();
          StartForward(FWDSPD);
					wait1Msec(2000);
					StopMotors();
					wait1Msec(1000);
					case_4();
					break;
					}
until(Current_x==Ball_x);
StopMotors();
break;
}
}
}
}

void case_4()
{
if((Deg_flag==1)||(Deg_flag%4==1))
RotationR_90();
else if((Deg_flag==4)||(Deg_flag%4==0))
RotationL_90();
while(true){
if((Current_x>Ball_x)&&(Current_y<Ball_y)){

StartForward(FWDSPD);

if((Current_x>Ball_x)&&(Current_y>Ball_y)){

if((Deg_flag==3)||(Deg_flag%4==3))
{
if(USreading()<Ultrasonic){
StopMotors();
wait1Msec(300);
RotationL_90();
if(USreading()<Ultrasonic){
RotationR_90();
//Go_straightline();
StartForward(-FWDSPD);
wait1Msec(1000);
StopMotors();
RotationL_90();
StartForward(FWDSPD);
                  }
else
StartForward(FWDSPD);
                  }
else
StartForward(FWDSPD);
}
if((Deg_flag==2)||(Deg_flag%4==2))
{
if(USreading()<Ultrasonic){
StopMotors();
wait1Msec(300);
RotationR_90();
if(USreading()<Ultrasonic){
RotationL_90();
StartForward(-FWDSPD);
wait1Msec(1000);
StopMotors();
RotationR_90();
StartForward(FWDSPD);
                  }
else
StartForward(FWDSPD);
                  }
else
StartForward(FWDSPD);
}

                  }

                                             }
else
{
StopMotors();
if((Deg_flag==3)||(Deg_flag%4==3))
{
wait1Msec(300);
RotationL_90();
StartForward(FWDSPD);

if(USreading()<Ultrasonic){
					RotationR_90();
          StartForward(FWDSPD);
					wait1Msec(2000);
					StopMotors();
					wait1Msec(1000);
					case_1();
					break;
					}
until(Current_y==Ball_y);
StopMotors();
break;
}
else if ((Deg_flag==2)||(Deg_flag%4==2)){
wait1Msec(300);
RotationR_90();
StartForward(FWDSPD);

if(USreading()<Ultrasonic){
					RotationL_90();
          StartForward(FWDSPD);
					wait1Msec(2000);
					StopMotors();
					wait1Msec(1000);
					case_3();
					break;
					}
until(Current_x==Ball_x);
StopMotors();
break;
}
}
}
}

task Navigate()
{
StartForward(FWDSPD);
if((Current_x<Ball_x)&&(Current_y<Ball_y))
case_1();
else if((Current_x<Ball_x)&&(Current_y>Ball_y))
case_2();
else if((Current_x>Ball_x)&&(Current_y>Ball_y))
case_3();
else if((Current_x>Ball_x)&&(Current_y<Ball_y))
case_4();
}

task main()
{
//	SensorType[IN_4] =
//  SetSensorLowspeed(IN_4);
  StartTask( Navigate);
  StartTask( odometer);
  while(true);
}
